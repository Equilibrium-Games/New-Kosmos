/*
 * Copyright (C) 2017, Equilibrium Games - All Rights Reserved.
 *
 * This source file is part of New Kosmos.
 *
 * Unauthorized copying of this file, via any medium is strictly prohibited.
 * Proprietary and confidential.
 */

package kosmos.world;

import flounder.entities.*;
import flounder.framework.*;
import flounder.helpers.*;
import flounder.logger.*;
import flounder.maths.*;
import flounder.maths.vectors.*;
import flounder.networking.*;
import flounder.noise.*;
import flounder.resources.*;
import flounder.textures.*;
import kosmos.*;
import kosmos.world.chunks.*;

import javax.imageio.*;
import java.awt.image.*;
import java.io.*;
import java.util.*;

/**
 * A object that defines a worlds generation parameters.
 */
public class WorldDefinition {
	// The size of the rendered map image.
	private static final int MAP_IMAGE_SIZE = 1000;

	private final String name;
	private final int seed;
	private final int worldSize;
	private final float worldNoiseSpread;
	private final float worldNoiseFrequency;
	private final float worldNoiseHeight;
	private final float worldIslandInside;
	private final float worldIslandOutside;
	private final float worldIslandParameter;

	private final float dayNightCycle;
	private final float dayNightRatio;

	private PerlinNoise noise;
	private TextureObject mapTexture;

	private Map<String, Pair<Vector3f, Vector3f>> players;
	private List<ChunkData> chunkData;

	/**
	 * Creates a new world save definition.
	 *
	 * @param name The name to be used in the save.
	 * @param seed The seed used for the world.
	 * @param worldSize The width and height of the world, in tile size.
	 * @param worldNoiseSpread The width of the islands generated by the noise.
	 * @param worldNoiseFrequency The frequency of roughness applied to the noise (lower is smoother).
	 * @param worldNoiseHeight The height multiplier, max world height.
	 * @param worldIslandInside The inside radius of the island shape.
	 * @param worldIslandOutside The outside radius of the island shape.
	 * @param worldIslandParameter The shape parameter (0=circular, 1=rectangular).
	 * @param dayNightCycle The day/night length (seconds).
	 * @param dayNightRatio The percentage of the time that is day.
	 * @param players The other players position and chunk position data.
	 * @param chunkData The data about all modified chunks in the save.
	 */
	public WorldDefinition(String name, int seed, int worldSize, float worldNoiseSpread, float worldNoiseFrequency, float worldNoiseHeight, float worldIslandInside, float worldIslandOutside, float worldIslandParameter, float dayNightCycle, float dayNightRatio,
	                       Map<String, Pair<Vector3f, Vector3f>> players, List<ChunkData> chunkData) {
		this.name = name;
		this.seed = seed;
		this.worldSize = worldSize;
		this.worldNoiseSpread = worldNoiseSpread;
		this.worldNoiseFrequency = worldNoiseFrequency;
		this.worldNoiseHeight = worldNoiseHeight;
		this.worldIslandInside = worldIslandInside;
		this.worldIslandOutside = worldIslandOutside;
		this.worldIslandParameter = worldIslandParameter;

		this.dayNightCycle = dayNightCycle;
		this.dayNightRatio = dayNightRatio;

		this.noise = new PerlinNoise(seed);
		this.mapTexture = null;

		this.players = players;
		this.chunkData = chunkData;
	}

	/**
	 * Generates a map for the current seed.
	 */
	public void generateMap() {
		// Account for the null seed.
		if (seed == -1) {
			if (mapTexture != null && mapTexture.isLoaded()) {
				mapTexture.delete();
			}

			return;
		}

		FlounderLogger.get().log("Generating map for seed: " + seed);

		//BufferedImage imageIsland = new BufferedImage(MAP_IMAGE_SIZE, MAP_IMAGE_SIZE, BufferedImage.TYPE_INT_RGB);
		//BufferedImage imageHeight = new BufferedImage(MAP_IMAGE_SIZE, MAP_IMAGE_SIZE, BufferedImage.TYPE_INT_RGB);
		//BufferedImage imageMoisture = new BufferedImage(MAP_IMAGE_SIZE, MAP_IMAGE_SIZE, BufferedImage.TYPE_INT_RGB);
		BufferedImage imageBiome = new BufferedImage(MAP_IMAGE_SIZE, MAP_IMAGE_SIZE, BufferedImage.TYPE_INT_RGB);

		for (int y = 0; y < MAP_IMAGE_SIZE; y++) {
			for (int x = 0; x < MAP_IMAGE_SIZE; x++) {
				float worldX = ((float) x / ((float) MAP_IMAGE_SIZE / (float) worldSize)) - ((float) worldSize / 2.0f);
				float worldZ = ((float) y / ((float) MAP_IMAGE_SIZE / (float) worldSize)) - ((float) worldSize / 2.0f);

				//float factorIsland = KosmosChunks.getIslandMap(worldX, worldZ);
				//imageIsland.setRGB(x, y, (((int) (255.0f * factorIsland) << 8) + ((int) (255.0f * factorIsland)) << 8) + ((int) (255.0f * factorIsland)));

				//float factorHeight = KosmosChunks.getHeightMap(worldX, worldZ);
				//imageHeight.setRGB(x, y, (((int) (255.0f * factorHeight) << 8) + ((int) (255.0f * factorHeight)) << 8) + ((int) (255.0f * factorHeight)));

				//float factorMoisture = KosmosChunks.getMoistureMap(worldX, worldZ);
				//Colour colourMoisture = Colour.interpolate(new Colour(1.0f, 0.0f, 0.0f), new Colour(0.0f, 0.0f, 1.0f), factorMoisture, null);
				//imageMoisture.setRGB(x, y, (((int) (255.0f * colourMoisture.r) << 8) + ((int) (255.0f * colourMoisture.g)) << 8) + ((int) (255.0f * colourMoisture.b)));

				Colour colourBiome = KosmosChunks.getBiomeMap(worldX, worldZ).getBiome().getColour();
				imageBiome.setRGB(x, y, (((int) (255.0f * colourBiome.r) << 8) + ((int) (255.0f * colourBiome.g)) << 8) + ((int) (255.0f * colourBiome.b)));
			}
		}

		File directorySave = new File(Framework.get().getRoamingFolder().getPath() + "/saves/");

		if (!directorySave.exists()) {
			System.out.println("Creating directory: " + directorySave);

			try {
				directorySave.mkdir();
			} catch (SecurityException e) {
				System.out.println("Filed to create directory: " + directorySave.getPath() + ".");
				e.printStackTrace();
			}
		}

		String clientServer = FlounderNetwork.get().getSocketServer() != null ? "server" : "client";
		//File outputIsland = new File(directorySave.getPath() + "/" + seed + "-island-" + clientServer + ".png");
		//File outputHeight = new File(directorySave.getPath() + "/" + seed + "-height-" + clientServer + ".png");
		//File outputMoisture = new File(directorySave.getPath() + "/" + seed + "-moisture-" + clientServer + ".png");
		File outputBiome = new File(directorySave.getPath() + "/" + seed + "-biome-" + clientServer + ".png");

		try {
			// Save the map texture.
			//ImageIO.write(imageIsland, "png", outputIsland);
			//ImageIO.write(imageHeight, "png", outputHeight);
			//ImageIO.write(imageMoisture, "png", outputMoisture);
			ImageIO.write(imageBiome, "png", outputBiome);

			// Remove old map texture.
			if (mapTexture != null && mapTexture.isLoaded()) {
				mapTexture.delete();
			}

			// Load the map texture after a few seconds.
			new java.util.Timer().schedule(
					new java.util.TimerTask() {
						@Override
						public void run() {
							mapTexture = TextureFactory.newBuilder().setFile(new MyFile(Framework.get().getRoamingFolder(), "saves", seed + "-biome-" + clientServer + ".png")).create();
						}
					},
					1000
			);
		} catch (IOException e) {
			FlounderLogger.get().error("Could not save map image to file: " + outputBiome);
			FlounderLogger.get().exception(e);
		}
	}

	public String getName() {
		return name;
	}

	/**
	 * Gets the seed used for the world.
	 *
	 * @return The seed.
	 */
	public int getSeed() {
		return seed;
	}

	/**
	 * Gets the width and height of the world, in tile size.
	 *
	 * @return The world size.
	 */
	public int getWorldSize() {
		return worldSize;
	}

	/**
	 * Gets the width of the islands generated by the noise.
	 *
	 * @return The world noise spread.
	 */
	public float getWorldNoiseSpread() {
		return worldNoiseSpread;
	}

	/**
	 * Gets the frequency of roughness applied to the noise (lower is smoother).
	 *
	 * @return The world noise frequency.
	 */
	public float getWorldNoiseFrequency() {
		return worldNoiseFrequency;
	}

	/**
	 * Gets the height multiplier, max world height.
	 *
	 * @return The world noise height.
	 */
	public float getWorldNoiseHeight() {
		return worldNoiseHeight;
	}

	/**
	 * Gets the inside radius of the island shape.
	 *
	 * @return The world island inside bound.
	 */
	public float getWorldIslandInside() {
		return worldIslandInside;
	}

	/**
	 * Gets the outside radius of the island shape.
	 *
	 * @return The world island outside bound.
	 */
	public float getWorldIslandOutside() {
		return worldIslandOutside;
	}

	/**
	 * Gets the shape parameter (0=circular, 1=rectangular).
	 *
	 * @return The world island circle-square parameter.
	 */
	public float getWorldIslandParameter() {
		return worldIslandParameter;
	}

	/**
	 * Gets the day/night length (seconds).
	 *
	 * @return The day night cycle length.
	 */
	public float getDayNightCycle() {
		return dayNightCycle;
	}

	/**
	 * Gets the percentage of the time that is day.
	 *
	 * @return The day night ratio.
	 */
	public float getDayNightRatio() {
		return dayNightRatio;
	}

	public PerlinNoise getNoise() {
		return noise;
	}

	public TextureObject getMapTexture() {
		return mapTexture;
	}

	public Map<String, Pair<Vector3f, Vector3f>> getPlayers() {
		return players;
	}

	public Vector3f getPlayerPosition(String username) {
		if (!players.containsKey(username)) {
			players.put(username, new Pair<>(new Vector3f(), new Vector3f()));
		}

		return players.get(username).getFirst();
	}

	public Vector3f getPlayerChunk(String username) {
		if (!players.containsKey(username)) {
			players.put(username, new Pair<>(new Vector3f(), new Vector3f()));
		}

		return players.get(username).getSecond();
	}

	public List<ChunkData> getChunkData() {
		return chunkData;
	}

	public ChunkData getChunk(Vector3f position) {
		for (ChunkData data : chunkData) {
			if (data.getPosition().equals(position)) {
				return data;
			}
		}

		return null;
	}

	public void save() {
		if (FlounderNetwork.get().getSocketClient() != null) {
			FlounderLogger.get().log("Cannot save multiplayer world on a client!");
			return;
		}

		FlounderLogger.get().log("Saving world: " + name);

		try {
			// The save file and the writers.
			File saveFile = new File(Framework.get().getRoamingFolder().getPath() + "/saves/" + name + ".save");
			saveFile.createNewFile();
			FileWriter fileWriter = new FileWriter(saveFile);
			FileWriterHelper fileWriterHelper = new FileWriterHelper(fileWriter);

			// Date and save info.
			String savedDate = Calendar.getInstance().get(Calendar.DAY_OF_MONTH) + "." + (Calendar.getInstance().get(Calendar.MONTH) + 1) + "." + Calendar.getInstance().get(Calendar.YEAR) + " - " + Calendar.getInstance().get(Calendar.HOUR_OF_DAY) + ":" + Calendar.getInstance().get(Calendar.MINUTE);
			fileWriterHelper.addComment("Automatically generated save file.", "Date generated: " + savedDate);

			// Versioning and seed.
			fileWriterHelper.beginNewSegment("save");
			{
				fileWriterHelper.writeSegmentData("version = " + NewKosmos.VERSION + ";", true);
				fileWriterHelper.writeSegmentData("seed = " + seed + ";", true);
				fileWriterHelper.writeSegmentData("worldSize = " + worldSize + ";", true);
				fileWriterHelper.writeSegmentData("worldNoiseSpread = " + worldNoiseSpread + ";", true);
				fileWriterHelper.writeSegmentData("worldNoiseFrequency = " + worldNoiseFrequency + ";", true);
				fileWriterHelper.writeSegmentData("worldNoiseHeight = " + worldNoiseHeight + ";", true);
				fileWriterHelper.writeSegmentData("worldIslandInside = " + worldIslandInside+ ";", true);
				fileWriterHelper.writeSegmentData("worldIslandOutside = " + worldIslandOutside + ";", true);
				fileWriterHelper.writeSegmentData("worldIslandParameter = " + worldIslandParameter + ";", true);
				fileWriterHelper.writeSegmentData("dayNightCycle = " + dayNightCycle + ";", true);
				fileWriterHelper.writeSegmentData("dayNightRatio = " + dayNightRatio + ";", false);
			}
			fileWriterHelper.endSegment(false);

			// Player data.
			fileWriterHelper.beginNewSegment("players");
			{
				Entity thisPlayer = KosmosWorld.get().getEntityPlayer();
				Chunk thisChunk = KosmosChunks.get().getCurrent();
				if (thisPlayer != null && thisChunk != null) {
					fileWriterHelper.writeSegmentData("\'this\', " + thisPlayer.getPosition().x + ", " + thisPlayer.getPosition().y + ", " + thisPlayer.getPosition().z + ", ");
					fileWriterHelper.writeSegmentData(thisChunk.getPosition().x + ", " + thisChunk.getPosition().y + ", " + thisChunk.getPosition().z + ";", true);
				}

				for (String username : players.keySet()) {
					Pair<Vector3f, Vector3f> data = players.get(username);
					fileWriterHelper.writeSegmentData("\'" + username + "\', " + data.getFirst().x + ", " + data.getFirst().y + ", " + data.getFirst().z + ", ");
					fileWriterHelper.writeSegmentData(data.getSecond().x + ", " + data.getSecond().y + ", " + data.getSecond().z, true);
				}
			}
			fileWriterHelper.endSegment(false);

			// Chunk data.
			fileWriterHelper.beginNewSegment("chunks");
			{
				for (ChunkData c : chunkData) {
					fileWriterHelper.writeSegmentData(c.getSaveData(), true);
				}
			}
			fileWriterHelper.endSegment(true);

			// Closes the file for writing.
			fileWriter.close();
		} catch (IOException e) {
			FlounderLogger.get().exception(e);
		}
	}

	public void dispose() {
		if (mapTexture != null) {
			mapTexture.delete();
		}
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;

		WorldDefinition that = (WorldDefinition) o;

		if (seed != that.seed) return false;
		if (worldSize != that.worldSize) return false;
		if (Float.compare(that.worldNoiseSpread, worldNoiseSpread) != 0) return false;
		if (Float.compare(that.worldNoiseFrequency, worldNoiseFrequency) != 0) return false;
		if (Float.compare(that.worldNoiseHeight, worldNoiseHeight) != 0) return false;
		if (Float.compare(that.worldIslandInside, worldIslandInside) != 0) return false;
		if (Float.compare(that.worldIslandOutside, worldIslandOutside) != 0) return false;
		if (Float.compare(that.worldIslandParameter, worldIslandParameter) != 0) return false;
		if (Float.compare(that.dayNightCycle, dayNightCycle) != 0) return false;
		if (Float.compare(that.dayNightRatio, dayNightRatio) != 0) return false;
		return true;
	}
}
